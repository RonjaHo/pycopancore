"""Culture process taxon mixing class exploit_social_learning_MOL_CC_SN."""

# This file is part of pycopancore.
#
# Copyright (C) 2016-2017 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# Contact: core@pik-potsdam.de
# License: BSD 2-clause license

from pycopancore.model_components.base import interface as B
from .. import interface as I
from .... import Step

import numpy as np
import networkx as nx


class Culture (I.Culture):
    """Culture process taxon mixin for exploit_social_learning3."""

    def __init__(self,
                 *,
                  value_neigh_con = 0,
                  value_neigh_sus = 0,
                  value_own_con = 0,
                  value_own_sus = 0,
                  value_norm_con = 0,
                  value_norm_sus = 0,
                  sus_ind = 0,
                  con_ind = 0,
                 **kwargs
                 ):
        """Initialize an instance of World.

        Parameters
        ----------
        agent_list
        """
        super(Culture, self).__init__(**kwargs)

        
        self.value_neigh_con = value_neigh_con
        self.value_neigh_sus = value_neigh_sus
        self.value_own_con = value_own_con
        self.value_own_sus = value_own_sus
        self.value_norm_con = value_norm_con
        self.value_norm_sus = value_norm_sus
        self.sus_ind = sus_ind
        self.con_ind = con_ind

    # process-related methods:

    def social_update(self, t):
        """Execute the social update as a batch update.

        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        for agent in self.acquaintance_network:
            agent.update_time = np.random.exponential()
        
        ordered_list = list(self.acquaintance_network)
        n = len(ordered_list)
        for i in range(n):
            already_sorted = True
            for j in range(n-i-1):
                if ordered_list[j].update_time > ordered_list[j+1].update_time:
                    ordered_list[j], ordered_list[j+1] = ordered_list[j+1], ordered_list[j]
                    already_sorted = False
            if already_sorted:
                break
            
        self.value_neigh_con = 0
        self.value_neigh_sus = 0
        self.value_own_con = 0
        self.value_own_sus = 0
        self.value_norm_con = 0
        self.value_norm_sus = 0
        self.sus_ind = 0
        self.con_ind = 0
        
        for agent_i in ordered_list:

            strategy = agent_i.strategy
            
            # updating
            
            identity_value = 0 # staying with own strategy = no update
            behaviour = agent_i.w_neighbors[strategy] * self.compare_to_neighbors(agent_i)\
                      + agent_i.w_ownland[strategy] * self.compare_to_own_land(agent_i) \
                      + agent_i.w_social_norm[strategy] * self.apply_social_norm(agent_i) \
                      + agent_i.w_identity[strategy] * identity_value
                      
            if strategy == 0 :
                self.con_ind += 1
                self.value_neigh_con += self.compare_to_neighbors(agent_i)
                self.value_own_con += self.compare_to_own_land(agent_i)
                self.value_norm_con += self.apply_social_norm(agent_i)
                
            if strategy == 1 :
                  self.sus_ind += 1
                  self.value_neigh_sus += self.compare_to_neighbors(agent_i)
                  self.value_own_sus += self.compare_to_own_land(agent_i)
                  self.value_norm_sus += self.apply_social_norm(agent_i)
                        
            if  np.random.random() < behaviour:
                agent_i.past_harvest_rate = agent_i.get_harvest_rate()
                agent_i.past_strategy = strategy
                agent_i.strategy =int(not agent_i.strategy)
                   
            # checking for consensus

            if self.check_for_consensus():
                print('Consensus! time ', t)
                
        if self.con_ind != 0:
            self.value_neigh_con = self.value_neigh_con/ self.con_ind
            self.value_own_con = self.value_own_con/ self.con_ind
            self.value_norm_con = self.value_norm_con/ self.con_ind
            
        if self.sus_ind != 0:
            self.value_neigh_sus = self.value_neigh_sus/ self.sus_ind
            self.value_own_sus = self.value_own_sus/ self.sus_ind
            self.value_norm_sus = self.value_norm_sus/ self.sus_ind
            
    def sigmoidal (self, x):
        return 0.5 * (np.tanh(x) + 1)
    
    def get_average_harvest_rates(self,agent_i):
        # group neighbors in sustainable and unsustainable neighbors
        sus_neighbors = []
        unsus_neighbors = []
        if self.acquaintance_network.neighbors(agent_i):
            neighbors_i = list(self.acquaintance_network.neighbors(agent_i))
            for neighbor in neighbors_i:
                if neighbor.strategy == 1:
                    sus_neighbors.append(neighbor)
                else:
                    unsus_neighbors.append(neighbor)                    
        # calculate average harvest rate for the sustainable and unsustainable
        # neighbors respectively
        if sus_neighbors:
            harvest_sus = sum(n.get_harvest_rate() for n in sus_neighbors)/len(sus_neighbors)
        else:
            harvest_sus = 0
        # average harvest of all sus_neighbors
        if unsus_neighbors:
            harvest_unsus = sum(n.get_harvest_rate() for n in unsus_neighbors)/len(unsus_neighbors)
        else:
                harvest_unsus = 0
        # average harvest of all sus_neighbors
        return harvest_unsus, harvest_sus
        

    def compare_to_neighbors(self, agent_i):
        """Comparison of agent i to all their neighbors in terms of yield and 
        eventually setting agent i's update strategy parameter to True.

        Agent i's update strategy pararmeter is set to True depending on the
        neighbors' harvest rates and strategies.

        Parameters
        ----------
        agent_i : Agent (Individual or SocialSystem)
            Agent i whose update parameter might to be changed 
       
        Returns
        
        compare_neigh_update
        
        agent i's strategy update parameter 
            This parameter is set to True depending on the outcome of the 
            comparison to agent i's neighbors. If the parameter is True, agent
            i's strategy should change from sus to unsus or unsus to sus 
            depending on the strategy before the update. If an actual update 
            of agent i's strategy happens depends on the weighted sum of all 
            update parameter from comparison to neighbors, comparison to own 
            land, social norm and identity values.
        -------
        """
        av_harvest_rates = self.get_average_harvest_rates(agent_i)
        harvest_rate_diff, harvest_rate_same = av_harvest_rates[not agent_i.strategy],av_harvest_rates[agent_i.strategy]
        return self.sigmoidal(harvest_rate_diff - agent_i.get_harvest_rate()) * np.heaviside(harvest_rate_diff - harvest_rate_same,0)

   
    def compare_to_own_land(self, agent_i):
        """Compare agent i to their past state (strategy and harvest rate) 
        before last update and eventually setting agent i's update strategy 
        parameter to True.


        Agent i's update strategy pararmeter is set to True depending on the
        on their past and current harvest rates.

        Parameters
        ----------
        agent_i : Agent (Individual or SocialSystem)
             Agent i whose update parameter might to be changed
        Returns
        
        compare_ownland_update
        
        agent i's strategy update parameter 
            This parameter is set to True depending on the outcome of the 
            comparison to agent i's past. If the parameter is True, agent
            i's strategy should change from sus to unsus or unsus to sus 
            depending on the strategy before the update. If an actual update 
            of agent i's strategy happens depends on the weighted sum of all 
            update parameter from comparison to neighbors, comparison to own 
            land, social norm and identity values.
        -------

         """
        return self.sigmoidal(agent_i.past_harvest_rate -
                                  agent_i.get_harvest_rate())
   
    def social_norm(self, agent_i):
        social_norm = 0
        if self.acquaintance_network.neighbors(agent_i):
            neighbors = list(self.acquaintance_network.neighbors(agent_i))
            social_norm = sum(n.strategy for n in neighbors)/len(neighbors)
        return social_norm
        
    
    def apply_social_norm(self, agent_i):
        """Apply social norm and eventually setting agent i's update strategy 
        parameter to True.


        Agent i's update strategy pararmeter is set to True depending on the
        social norm imposed by agent i's neighbors.

        Parameters
        ----------
        agent_i : Agent (Individual or SocialSystem)
             Agent i whose update parameter might to be changed
        Returns
        
        social_norm_update
        
        agent i's strategy update parameter 
            This parameter is set to True depending on the imposed social norm. 
            If the parameter is True, agent i's strategy should change from sus
            to unsus or unsus to sus depending on the strategy before the 
            update. If an actual update of agent i's strategy happens depends 
            on the weighted sum of all update parameter from comparison to 
            neighbors, comparison to own land, social norm and identity values.
        -------

         """
        if agent_i.strategy == 1:
          return np.heaviside(0.5-self.social_norm(agent_i),0) 
          #return self.sigmoidal(0.5-self.social_norm(agent_i))
        else:
            return np.heaviside(self.social_norm(agent_i)-0.5,0)  
            #return self.sigmoidal(self.social_norm(agent_i)-0.5)             

    

    def check_for_consensus(self):
        """Check if the model has run into a consensus state.

        The model is in a consensus state if in each connected component
        all agents use the same strategy. In this case, there will be no more
        change of strategies since the agents are only connected to agents
        with the same strategy.

        Returns
        -------
        consensus : bool
            True if model is into consensus state, otherwise False
        """
        cc = nx.connected_components(self.acquaintance_network)
        # iterate through all connected components
        for component in cc:
            # iterate through all agents in this component
            stratlist = []
            for j in component:
                # check if all agents of component have the same strategy
                stratlist.append(j.strategy)
            if stratlist.count(stratlist[0]) != len(stratlist):
                self.consensus = False
                return self.consensus

        # If in each component, all agents have the same strategy, then a
        # consensus state is reached
        self.consensus = True
        return self.consensus

    def step_timing(self,t):
        """Return the next time step is to be called.

        This function is used to get to know when the step function is
        to be called.
        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        return t + np.random.exponential(self.average_waiting_time)
    
    processes = [Step('Social Update is a step function',
                      [B.Culture.worlds.individuals.strategy,
                       I.Culture.consensus,I.Culture.value_neigh_con,I.Culture.value_neigh_sus,I.Culture.value_own_con,
                       I.Culture.value_own_sus,I.Culture.value_norm_con,I.Culture.value_norm_sus],
                      [step_timing, social_update])]
