"""Culture process taxon mixing class exploit_social_learning_MOL_CC_SN."""

# This file is part of pycopancore.
#
# Copyright (C) 2016-2017 by COPAN team at Potsdam Institute for Climate
# Impact Research
#
# URL: <http://www.pik-potsdam.de/copan/software>
# Contact: core@pik-potsdam.de
# License: BSD 2-clause license

from pycopancore.model_components.base import interface as B
from .. import interface as I
from .... import Step

import numpy as np
import networkx as nx


class Culture (I.Culture):
    """Culture process taxon mixin for exploit_social_learning3."""

    # process-related methods:

    def social_update(self, t):
        """Execute the social update.

        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        self.last_execution_time = t
        agent_i = self.get_update_agent()
        strategy = agent_i.strategy
        
        # update part
        
        identity_value = 0 # staying with own strategy = no update
        behaviour = agent_i.w_neighbors[strategy] * self.compare_to_neighbors(agent_i)\
                  + agent_i.w_ownland[strategy] * self.compare_to_own_land(agent_i) \
                  + agent_i.w_social_norm[strategy] * self.apply_social_norm(agent_i) \
                  + agent_i.w_identity[strategy] * identity_value
        if  np.random.random() < behaviour:
            agent_i.past_harvest_rate = agent_i.get_harvest_rate()
            agent_i.past_strategy = strategy
            agent_i.strategy =int(not agent_i.strategy)
               
        # last Step
        self.set_new_update_time(agent_i)

        if self.check_for_consensus():
            print('Consensus! time ', t)
            
    def sigmoid (self, x):
        return 0.5 * (np.tanh(x) + 1)
    
    def get_average_harvest_rates(self,agent_i):
        # group neighbors in sustainable and unsustainable neighbors
        sus_neighbors = []
        unsus_neighbors = []
        if self.acquaintance_network.neighbors(agent_i):
            neighbors_i = list(self.acquaintance_network.neighbors(agent_i))
            for neighbor in neighbors_i:
                if neighbor.strategy == 1:
                    sus_neighbors.append(neighbor)
                else:
                    unsus_neighbors.append(neighbor)                    
        # calculate average harvest rate for the sustainable and unsustainable
        # neighbors respectively
        if sus_neighbors:
            harvest_sus = sum(n.get_harvest_rate() for n in sus_neighbors)/len(sus_neighbors)
        else:
            harvest_sus = 0
        # average harvest of all sus_neighbors
        if unsus_neighbors:
            harvest_unsus = sum(n.get_harvest_rate() for n in unsus_neighbors)/len(unsus_neighbors)
        else:
                harvest_unsus = 0
        # average harvest of all sus_neighbors
        return harvest_unsus, harvest_sus
        

    def compare_to_neighbors(self, agent_i):
        """Comparison of agent i to all their neighbors in terms of yield and 
        eventually setting agent i's update strategy parameter to True.

        Agent i's update strategy pararmeter is set to True depending on the
        neighbors' harvest rates and strategies.

        Parameters
        ----------
        agent_i : Agent (Individual or SocialSystem)
            Agent i whose update parameter might to be changed 
       
        Returns
        
        compare_neigh_update
        
        agent i's strategy update parameter 
            This parameter is set to True depending on the outcome of the 
            comparison to agent i's neighbors. If the parameter is True, agent
            i's strategy should change from sus to unsus or unsus to sus 
            depending on the strategy before the update. If an actual update 
            of agent i's strategy happens depends on the weighted sum of all 
            update parameter from comparison to neighbors, comparison to own 
            land, social norm and identity values.
        -------
        """
        av_harvest_rates = self.get_average_harvest_rates(agent_i)
        harvest_rate_diff, harvest_rate_same = av_harvest_rates[not agent_i.strategy],av_harvest_rates[agent_i.strategy]
        return self.heavyside(harvest_rate_diff - agent_i.get_harvest_rate()) * np.heaviside(harvest_rate_diff - harvest_rate_same,0)

   
    def compare_to_own_land(self, agent_i):
        """Compare agent i to their past state (strategy and harvest rate) 
        before last update and eventually setting agent i's update strategy 
        parameter to True.


        Agent i's update strategy pararmeter is set to True depending on the
        on their past and current harvest rates.

        Parameters
        ----------
        agent_i : Agent (Individual or SocialSystem)
             Agent i whose update parameter might to be changed
        Returns
        
        compare_ownland_update
        
        agent i's strategy update parameter 
            This parameter is set to True depending on the outcome of the 
            comparison to agent i's past. If the parameter is True, agent
            i's strategy should change from sus to unsus or unsus to sus 
            depending on the strategy before the update. If an actual update 
            of agent i's strategy happens depends on the weighted sum of all 
            update parameter from comparison to neighbors, comparison to own 
            land, social norm and identity values.
        -------

         """
        return self.sigmoid(agent_i.past_harvest_rate -
                                  agent_i.get_harvest_rate())
   
    def social_norm(self, agent_i):
        social_norm = 0
        if self.acquaintance_network.neighbors(agent_i):
            neighbors = list(self.acquaintance_network.neighbors(agent_i))
            social_norm = sum(n.strategy for n in neighbors)/len(neighbors)
        return social_norm
        
    
    def apply_social_norm(self, agent_i):
        """Apply social norm and eventually setting agent i's update strategy 
        parameter to True.


        Agent i's update strategy pararmeter is set to True depending on the
        social norm imposed by agent i's neighbors.

        Parameters
        ----------
        agent_i : Agent (Individual or SocialSystem)
             Agent i whose update parameter might to be changed
        Returns
        
        social_norm_update
        
        agent i's strategy update parameter 
            This parameter is set to True depending on the imposed social norm. 
            If the parameter is True, agent i's strategy should change from sus
            to unsus or unsus to sus depending on the strategy before the 
            update. If an actual update of agent i's strategy happens depends 
            on the weighted sum of all update parameter from comparison to 
            neighbors, comparison to own land, social norm and identity values.
        -------

         """
        if agent_i.strategy == 1:
          return np.heaviside(0.5-self.social_norm(agent_i),0) 
          #return self.heavyside(0.5-self.social_norm(agent_i))
        else:
            return np.heaviside(self.social_norm(agent_i)-0.5,0)  
            #return self.heavyside(self.social_norm(agent_i)-0.5)             

    def get_update_agent(self):
        """Return the agent with the closest waiting time.

        Choose from all agents the one with the smallest update_time.
        Returns
        -------

        """
        next_agent = list(self.acquaintance_network.nodes())[0]
        for agent in self.acquaintance_network:
            if agent.update_time < next_agent.update_time:
                next_agent = agent
        return next_agent

    def set_new_update_time(self, agent):
        """Set next time step when agent is to be called again.

        Set the attribute update_time of agent to
        old_update_time + new_update_time, where new_update_time is again
        drawn from an exponential distribution.

        Parameters
        ----------
        agent : Agent (Individual or SocialSystem)
            The agent whose new update_time should be drawn and set.

        Returns
        -------

        """
        # print('old_update_time: ',individual.update_time)
        new_update_time = np.random.exponential(agent.average_waiting_time)
        agent.update_time += new_update_time

    def check_for_consensus(self):
        """Check if the model has run into a consensus state.

        The model is in a consensus state if in each connected component
        all agents use the same strategy. In this case, there will be no more
        change of strategies since the agents are only connected to agents
        with the same strategy.

        Returns
        -------
        consensus : bool
            True if model is into consensus state, otherwise False
        """
        cc = nx.connected_components(self.acquaintance_network)
        # iterate through all connected components
        for component in cc:
            # iterate through all agents in this component
            stratlist = []
            for j in component:
                # check if all agents of component have the same strategy
                stratlist.append(j.strategy)
            if stratlist.count(stratlist[0]) != len(stratlist):
                self.consensus = False
                return self.consensus

        # If in each component, all agents have the same strategy, then a
        # consensus state is reached
        self.consensus = True
        return self.consensus

    def step_timing(self,
                    t):
        """Return the next time step is to be called.

        This function is used to get to know when the step function is
        to be called.
        Parameters
        ----------
        t : float
            time

        Returns
        -------

        """
        if isinstance(self.last_execution_time, type(None)):
            self.last_execution_time = 0
        if t < self.last_execution_time:
            print('last execution time after t!')

        next_time = list(self.acquaintance_network.nodes())[0].update_time
        for agent in self.acquaintance_network:
            if agent.update_time < next_time:
                next_time = agent.update_time
        if t > next_time:
            print('next update time before t!')
        return next_time

    processes = [Step('Social Update is a step function',
                      [I.Culture.acquaintance_network,
                       B.Culture.worlds.individuals.strategy, B.Culture.worlds.individuals.update_time,
                       I.Culture.consensus],
                      [step_timing, social_update])]
